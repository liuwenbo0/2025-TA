# Lab1 拓展题

本目录包含两个拓展题的完整实现和测试框架。

## 目录结构

```
lab1/ext/
├── data/                    # 测试数据
│   ├── queue/              # 队列测试数据
│   │   ├── input1.txt      # 测试用例1输入
│   │   ├── output1.txt     # 测试用例1期望输出
│   │   ├── input2.txt      # 测试用例2输入
│   │   ├── ...             # 更多测试用例
│   └── monostack/          # 单调栈测试数据
│       ├── input1.txt      # 测试用例1输入
│       ├── output1.txt     # 测试用例1期望输出
│       ├── ...             # 更多测试用例
├── include/                # 头文件
│   ├── ExtQueueTwoStacks.hpp    # 两个栈实现队列
│   └── ExtMonotonicStack.hpp    # 单调栈实现
├── gen.cpp                 # 随机生成10组测试数据
├── check_queue.cpp         # 判题脚本A：两个栈实现队列
├── check_monostack.cpp     # 判题脚本B：单调栈
├── main.cpp               # 演示程序
└── README.md              # 本文件
```

## 拓展题目

### 拓展题1：用两个栈实现队列（摊还 O(1)）

**要求：** 只使用两个栈支持 `push(x)`、`pop()`、`front()`，并说明摊还时间复杂度为何为 O(1)。

**算法思路：**
- 使用两个栈：`stack1`（用于push）和 `stack2`（用于pop和front）
- push操作：直接压入stack1，时间复杂度O(1)
- pop/front操作：
  - 如果stack2非空，直接操作stack2顶部，O(1)
  - 如果stack2为空，将stack1所有元素转移到stack2，然后操作

**摊还分析：**
- 每个元素最多被转移一次（从stack1到stack2）
- 虽然单次转移可能是O(n)，但平摊到所有操作上是O(1)
- 总的摊还时间复杂度为O(1)

### 拓展题2：单调栈：右侧第一个更大元素

**要求：** 给定数组，输出每个位置右侧第一个严格更大元素的下标（不存在则输出 -1）。时间复杂度 O(n)。

**算法思路：**
- 使用单调递减栈（存储数组下标）
- 从右到左遍历数组
- 对于当前元素，弹出栈中所有小于等于当前元素的元素
- 栈顶元素就是右侧第一个更大的元素
- 将当前元素下标压入栈

**时间复杂度分析：**
- 每个元素最多入栈和出栈各一次
- 总时间复杂度为O(n)

## 编译和运行

### 基本演示
```bash
# 编译演示程序
g++ -std=c++17 -o main main.cpp

# 运行演示
./main
```

### 生成测试数据
```bash
# 编译数据生成器
g++ -std=c++17 -o gen gen.cpp

# 生成测试数据
./gen
```

### 运行判题脚本

**测试队列实现：**
```bash
# 编译判题脚本
g++ -std=c++17 -o check_queue check_queue.cpp

# 运行测试（需要先生成测试数据）
./check_queue
```

**测试单调栈实现：**
```bash
# 编译判题脚本
g++ -std=c++17 -o check_monostack check_monostack.cpp

# 运行测试（需要先生成测试数据）
./check_monostack
```

### 一键测试脚本
```bash
# 编译所有程序并运行完整测试
g++ -std=c++17 -o gen gen.cpp && ./gen
g++ -std=c++17 -o check_queue check_queue.cpp && ./check_queue
g++ -std=c++17 -o check_monostack check_monostack.cpp && ./check_monostack
```

## 实现要点

### 队列实现关键点
1. **正确的转移时机**：只有在stack2为空且需要pop/front时才转移
2. **异常处理**：对空队列的操作要抛出异常
3. **摊还分析**：理解为什么平均时间复杂度是O(1)

### 单调栈实现关键点
1. **栈的单调性**：维护单调递减栈
2. **遍历方向**：从右到左遍历数组
3. **栈中存储内容**：存储数组下标而不是值
4. **时间复杂度**：每个元素最多入栈出栈一次

## 测试数据说明

### 队列测试数据格式
```
操作数量
操作1 [参数]
操作2 [参数]
...
```

操作类型：
- `push x`：向队列尾部添加元素x
- `pop`：从队列头部移除元素
- `front`：获取队列头部元素

### 单调栈测试数据格式
**输入：**
```
数组大小n
n个整数（数组元素）
```

**输出：**
```
n个整数（每个位置右侧第一个更大元素的下标，-1表示不存在）
```

## 性能分析

程序包含性能测试，会测试不同规模数据下的运行时间：
- 验证O(1)摊还复杂度（队列）
- 验证O(n)时间复杂度（单调栈）
- 与暴力解法进行对比

## 注意事项

1. 使用C++17标准编译（需要filesystem支持）
2. 确保数据目录存在（gen.cpp会自动创建）
3. 判题脚本需要先运行数据生成器
4. 所有测试都包含正确性验证和性能分析

## 学习目标

通过这两个拓展题，学生将掌握：
1. 摊还分析的方法和思路
2. 单调栈的原理和应用
3. 时间复杂度分析
4. 数据结构的灵活运用
5. 算法正确性验证方法