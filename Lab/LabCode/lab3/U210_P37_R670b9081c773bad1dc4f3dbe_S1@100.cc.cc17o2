#include "HeapSort.h"  
  
void HeapSort::max_heapify(std::vector<int>& nums, int i) {  
    int left = 2 * i;   // 左子节点  
    int right = 2 * i + 1; // 右子节点  
    int largest = i;    // 初始化最大值为根节点  
  
    // 如果左子节点大于根节点，则更新最大值  
    if (left <= heap_size && nums[left] > nums[largest])  
        largest = left;  
  
    // 如果右子节点大于当前最大值，则更新最大值  
    if (right <= heap_size && nums[right] > nums[largest])  
        largest = right;  
  
    // 如果最大值不是根节点，则交换并继续堆化  
    if (largest != i) {  
        std::swap(nums[i], nums[largest]);  
        max_heapify(nums, largest);  
    }  
}  
  
void HeapSort::build_max_heap(std::vector<int>& nums) {  
    heap_size = nums.size() - 1; // 减去插入的0，实际堆的大小  
    // 从最后一个非叶子节点开始向上堆化  
    for (int i = heap_size / 2; i >= 1; --i) {  
        max_heapify(nums, i);  
    }  
}  
  
void HeapSort::mysort(std::vector<int>& nums) {  
    length = nums.size();  
    nums.insert(nums.begin(), 0); // 在开头插入一个元素，使得待排序元素下标从 1 开始  
    heap_size = nums.size() - 1; // 减去插入的0，设置堆的大小  
  
    // 构建最大堆  
    build_max_heap(nums);  
  
    // 一个个从堆顶取出元素，放到数组末尾，然后重新堆化  
    for (int i = heap_size; i > 1; --i) {  
        std::swap(nums[1], nums[i]);  
        --heap_size;  
        max_heapify(nums, 1);  
    }  
  
    nums.erase(nums.begin()); // 删除开头元素  
}