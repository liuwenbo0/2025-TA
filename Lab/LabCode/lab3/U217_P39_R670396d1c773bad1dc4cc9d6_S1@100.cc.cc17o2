#include "ThreeWayQuickSort.h"
int median_of_three(const std::vector<int>& nums, int a, int b, int c) {  
    int mid1 = nums[a] < nums[b] ? a : b;  
    int mid2 = nums[mid1] < nums[c] ? mid1 : c;  
    return mid2;  
}  
void ThreeWayQuickSort::three_way_quick_sort(std::vector<int>& nums, int p, int q) {
  if (p >= q) return; // 如果区间无效，则直接返回  
  
    // 使用三数取中法选择基准值  
    int mid = p + (q - p) / 2;  
    int pivot_index = median_of_three(nums, p, mid, q);  
    std::swap(nums[p], nums[pivot_index]);  
    int pivot = nums[p];  
  
    int lt = p; // 小于基准值的分区索引  
    int gt = q; // 大于基准值的分区索引  
    int i = p + 1; // 当前处理的元素索引  
  
    while (i <= gt) {  
        if (nums[i] < pivot) {  
            std::swap(nums[lt++], nums[i++]);  
        } else if (nums[i] > pivot) {  
            std::swap(nums[i], nums[gt--]);  
        } else {  
            i++; // 元素等于基准值，不移动位置  
        }  
    }  
  
    // 递归地对小于和大于基准值的部分进行三路快速排序  
    three_way_quick_sort(nums, p, lt - 1);  
    three_way_quick_sort(nums, gt + 1, q);  
}

void ThreeWayQuickSort::mysort(std::vector<int>& nums) {
    if (nums.size() == 0) 
        return;
    three_way_quick_sort(nums, 0, nums.size() - 1);
}