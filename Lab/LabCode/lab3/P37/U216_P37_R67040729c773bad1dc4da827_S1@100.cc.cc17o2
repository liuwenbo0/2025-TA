#include "HeapSort.h"
void HeapSort::max_heapify(std::vector<int>& nums, int i) {
    int left = 2 * i;       
    int right = 2 * i + 1;  
    int largest = i;        // 将初始化最大元素索引设置为i

    // 如果左子节点的值大于根节点，则替换更新最大元素索引
    if (left <= length && nums[left] > nums[largest])
     {
        largest = left;
    }

    // 如果右子节点比当前最大元素的值还大，则替换更新最大元素索引
    if (right <= length && nums[right] > nums[largest]) 
    {
        largest = right;
    }

    // 如果最大元素不是当前根节点，将最大元素和根节点的位置交换，并逐个递归调正子堆让其不受影响
    if (largest != i)
     {
        std::swap(nums[i], nums[largest]);
        max_heapify(nums, largest);
    }
}
// 请在这里完成你的代码


void HeapSort::build_max_heap(std::vector<int>& nums) {
     // 从最后一个不是叶子节点的地方向上构建最大堆
    for (int i = length / 2; i >= 1; --i)
     {
        max_heapify(nums, i);
    }
}// 请在这里完成你的代码


void HeapSort::mysort(std::vector<int>& nums) {
    length = nums.size();
    nums.insert(nums.begin(), 0); // 在开头插入一个元素，使得待排序元素下标从 1 开始
    // 构建最大堆
    build_max_heap(nums);

    // 将输出的值排序，在每一次循环时将最大值移动到数组的末尾，然后依次调整堆，直到整个输出完成排序
    for (int i = length; i >= 2; --i)
     {
        std::swap(nums[1], nums[i]); // 交换堆顶元素（即最大的值）和输出最后一个值
        --length; // 完成这一次后，减小堆的大小
        max_heapify(nums, 1); // 调整剩余堆的顺序
    }
// 请在这里完成你的代码

    nums.erase(nums.begin()); // 删除开头元素
}