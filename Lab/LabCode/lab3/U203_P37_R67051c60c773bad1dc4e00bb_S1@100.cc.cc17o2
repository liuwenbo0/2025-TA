#include "HeapSort.h"  
  
void HeapSort::max_heapify(std::vector<int>& nums, int i) {  
    int largest = i;  // 初始化最大值为根节点  
    int left = 2 * i; // 左子节点  
    int right = 2 * i + 1; // 右子节点  
  
    // 如果左子节点存在且大于根节点  
    if (left <= heap_size && nums[left] > nums[largest])  
        largest = left;  
  
    // 如果右子节点存在且大于目前最大的节点  
    if (right <= heap_size && nums[right] > nums[largest])  
        largest = right;  
  
    // 如果最大值不是根节点  
    if (largest != i) {  
        std::swap(nums[i], nums[largest]);  
  
        // 递归地维护堆的性质  
        max_heapify(nums, largest);  
    }  
}  
  
void HeapSort::build_max_heap(std::vector<int>& nums) {  
    heap_size = nums.size() - 1; // 排除插入的0元素  
  
    // 从最后一个非叶子节点开始维护堆的性质  
    for (int i = heap_size / 2; i >= 1; --i) {  
        max_heapify(nums, i);  
    }  
}  
  
void HeapSort::mysort(std::vector<int>& nums) {  
    length = nums.size();  
    nums.insert(nums.begin(), 0); // 在开头插入一个元素，使得待排序元素下标从 1 开始  
    heap_size = length; // 初始化堆大小  
  
    build_max_heap(nums); // 构建最大堆  
  
    // 一个个将最大元素（堆顶）放到数组末尾，并调整堆  
    for (int i = length; i > 1; --i) {  
        std::swap(nums[1], nums[i]);  
        --heap_size;  
        max_heapify(nums, 1);  
    }  
  
    nums.erase(nums.begin()); // 删除开头元素  
}  
  
/* 示例代码用于自测  
int main() {  
    HeapSort sorter;  
    std::vector<int> nums = {5, 2, 4, 2, 3, 1};  
      
    sorter.mysort(nums);  
  
    for (int num : nums) {  
        std::cout << num << " ";  
    }  
    std::cout << std::endl;  
  
    return 0;  
}*/