#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

// 递归计算从节点 i 开始的最大资源值
int pre(vector<int>& data, int i) {
    int n = data.size();
    // 如果索引超出范围或节点值为-1，返回0
    if (i >= n || data[i] == -1) return 0;
    // 计算左右子节点的最大资源值，并加上当前节点的值
    int temp = max(pre(data, 2 * i + 1), pre(data, 2 * i + 2)) + data[i];
    return temp;
}

int main() {
    vector<int> data;
    int node, result, height = 0;
    long long specialNodesSum = 0;
    
    // 读取输入直到输入结束
    while (cin >> node) {
        data.push_back(node);
    }
    
    result = data.size();
    // 计算完全二叉树的高度
    node = 0;
    if (result) {
        node = 1;
        while (node <= result) {
            node *= 2;
            height++;
        }
    }
    
    // 寻找所有非叶子节点，且节点值大于其子节点的值
    int leftChildExists = 0, rightChildExists = 0;
    for (int i = 0; i < result; ++i) {
        if (i * 2 + 1 < result && data[i * 2 + 1] != -1) {
            leftChildExists = 1;
        }
        if (i * 2 + 2 < result && data[i * 2 + 2] != -1) {
            rightChildExists = 1;
        }
        if (leftChildExists || rightChildExists) {
            if (leftChildExists && rightChildExists && data[i] > data[i * 2 + 1] && data[i] > data[i * 2 + 2]) {
                specialNodesSum += data[i];
            } else if (leftChildExists && data[i] > data[i * 2 + 1] && !rightChildExists) {
                specialNodesSum += data[i];
            } else if (rightChildExists && data[i] > data[i * 2 + 2] && !leftChildExists) {
                specialNodesSum += data[i];
            }
        }
        leftChildExists = 0, rightChildExists = 0;
    }
    
    // 输出树的高度、最大资源值和特殊节点值的总和
    cout << height << endl << pre(data, 0) << endl << specialNodesSum << endl;
    return 0;
}