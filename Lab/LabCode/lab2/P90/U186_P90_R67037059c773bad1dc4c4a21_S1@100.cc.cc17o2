#include <iostream>  
#include <vector>  
#include <algorithm>  
#include <climits>  
using namespace std;  
  
// 定义二叉树结点结构  
struct TreeNode {  
    int val;  
    TreeNode* left;  
    TreeNode* right;  
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}  
};  
  
// 构建二叉树  
TreeNode* buildTree(const vector<int>& data, int index) {  
    if (index>=data.size()||data[index] == -1) {  
        return NULL;  
    }  
    TreeNode*root = new TreeNode(data[index]);    
    root->left = buildTree(data, 2*index+1);  
    root->right = buildTree(data, 2*index+2);  
    return root;  
}  
  
// 计算树的高度  
int treeHeight(TreeNode* root) {  
    if (!root) return 0;  
    return 1 + max(treeHeight(root->left), treeHeight(root->right));  
}  
  
// 查找资源最丰富的路径（深度优先搜索）  
int maxPathSum(TreeNode* root, int& maxSum) {  
    if (root == NULL) return 0;  
    if(!root->left && !root->right) return root->val;
    int leftSum = maxPathSum(root->left, maxSum);  
    int rightSum = maxPathSum(root->right, maxSum);  
    int Sum = max(leftSum,rightSum);  
    maxSum = max(maxSum, Sum+root->val);  
    return root->val + max(leftSum, rightSum);  
}  
  
// 查找特殊区域结点值之和  
void specialRegionsSum(TreeNode* root, int& sum) {  
    if (!root) return;  
    if (!root->left && !root->right) return;
    bool flag=true;
    if(root->left){
        specialRegionsSum(root->left,sum);
        if(root->val<=root->left->val) flag=false;
    }   
    if(root->right){
        specialRegionsSum(root->right,sum);
        if(root->val<=root->right->val) flag=false;
    } 
    if(flag){
        sum+=root->val;
    }
}  
  
int main() {  
    vector<int> data;  
    int temp;
    while(cin>>temp){
        data.push_back(temp);
    } 
    TreeNode* root = buildTree(data, 0);  
  
    // 计算树的高度  
    int height = treeHeight(root);  
    cout << height << endl;  
  
    // 计算资源最丰富的路径  
    int maxSum = INT_MIN;  
    maxPathSum(root, maxSum);  
    cout << maxSum << endl;  
  
    // 计算特殊区域结点值之和  
    int sum=0;
    specialRegionsSum(root,sum);
    cout << sum << endl;  
  
    return 0;  
}