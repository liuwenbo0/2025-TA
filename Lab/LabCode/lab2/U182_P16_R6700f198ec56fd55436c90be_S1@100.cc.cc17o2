#include "Solution.h"
int Solution::find_maximum_crossing_subarray(vector<int> &A, int low, int mid, int high) {
    // 请在这里完成你的代码

    //cout << "cross" << " " << low << mid << high << endl;

    long long left_sum = LLONG_MIN;
    long long sum = 0;
//    long long max_left = 0;
    int i = 0;
    for (i = mid; i >= low; i--){
      sum += A[i];

      //cout << A[i] << "sum_A[i]" << endl;
      
      if(sum > left_sum){
        left_sum = sum;
//        max_left = i;
      }
    }
    long long right_sum = LLONG_MIN;
    sum = 0;
//    long long max_right = 0;
    int j = 0;
    for (j = mid + 1; j <= high; j++){
      sum += A[j];
      //cout << A[j] << "right_A[j]" << endl;
      if(sum > right_sum){
        right_sum = sum;
        //cout << sum << "right_sum" << endl;
//        max_right = j;
      }
    }
    if(left_sum >= 0){
      if(right_sum >=0){

        //cout << left_sum + right_sum<< endl;

        return (left_sum + right_sum);
      }else {

        //cout << left_sum << endl;

        return left_sum;
        }
    }else{
      if (left_sum >= right_sum){
        
        //cout << left_sum<< endl;

        return left_sum;
      }else {

        //cout << right_sum<< endl;
        
        return right_sum;
        }
    }
}
int Solution::find_maximum_subarray(vector<int> &A, int low, int high) {
    // 请在这里完成你的代码

    //cout << "side" << " " << low << high << endl;

    int mid = 0;
    if(high == low){
      return A[low];
    }else {
      mid = (low + high)/2;
      //cout << mid << "mid" <<endl;
      long long left_sum = find_maximum_subarray(A, low, mid);
      long long right_sum =find_maximum_subarray(A, mid+1, high);
     long long cross_sum = find_maximum_crossing_subarray(A, low, mid, high);
      if ((left_sum >= right_sum) && (left_sum >= cross_sum)){
        return left_sum;
      }else if((right_sum >= left_sum) && (right_sum >= cross_sum)){
        return right_sum;
      }else return cross_sum;
    }
}