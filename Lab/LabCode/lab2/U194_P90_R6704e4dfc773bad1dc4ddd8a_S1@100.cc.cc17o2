#include <iostream>
#include <cmath>
#include <iomanip>
#include <vector>

using namespace std;

//判断是否为叶子节点
bool is_leave(vector<int> &arr, int i)
{

	if (arr[i] != -1)
	{
		if (2 * i > arr.size() || 2 * i + 1 > arr.size())
			return true;
		else if (arr[2 * i] == -1 && arr[2 * i + 1] == -1)
			return true;
		else return false;
	}

	return false;
}

//层序遍历输入
void imput_tree(vector<int>& arr)
{
	int test;
	while (1)
	{
		if (cin >> test && !cin.eof())
		{
			if (test == -1)
			{
				test = -1;
			}
		}
		else break;
		arr.push_back(test);
	}
}

//补全为满二叉树
void make_up_fulltree(vector<int>& arr, int height)
{
	for (int i = arr.size(); i < pow(2, height); i++)
	{
		arr.push_back(-1);
	}
}


//求树的高度
int height_of_tree(vector<int>&arr)
{
	int height = floor(log2(arr.size()-1)) + 1;
	return height;
}

//求出最富裕路径和
int richest_resourse(vector<int> &arr)
{
	int father_node = 0;
	int sum = 0;
	int max_sum = 0;
	for (int i = 1; i < arr.size(); i++)
	{
		if (is_leave(arr, i))
		{
			sum = arr[i];
			int father_node = i / 2;

			while (father_node >= 1) {
				sum += arr[father_node];
				father_node /= 2;
			}
		}
		if (sum > max_sum)
		{
			max_sum = sum;
		}
		sum = 0;
	}

	return max_sum;

}

//求出特殊节点和
int sum_special_node(vector<int> &arr,int height)
{
	int sum = 0;
	for (int i = 1; i < pow(2, height); i++)
	{
		if (is_leave(arr, i) || arr[i] == -1)
			continue;
		else if (2 * i > pow(2, height) || 2 * i + 1 > pow(2, height))
			continue;
		else if (arr[2 * i] == -1 && arr[2 * i + 1] == -1)
			continue;
		else if (arr[i] > arr[2 * i] && arr[i] > arr[2 * i + 1])
			sum += arr[i];
	}
	return sum;
}

int main()
{
	vector<int> arr = { 0 };
	imput_tree(arr);
	int height = height_of_tree(arr);
	make_up_fulltree(arr, height);
	//输出自测
	//for (int i = 0; i < arr.size(); i++)
	//{
	//	cout << arr[i] << ' ';
	//}
	//cout << endl;
	int max_sum = richest_resourse(arr);
	int special_sum = sum_special_node(arr,height);

	cout << height << endl;
	cout << max_sum << endl;
	cout << special_sum << endl;

	return 0;
	
}