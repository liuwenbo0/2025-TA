#include<iostream>
#include<vector>
using namespace std;
int R(vector<int> &x, int p) 
{
    int c = x.size();
    if(p >= c || x[p] == -1)
    return 0;
    int d = (R(x, 2 * p + 1) > R(x, 2 * p + 2) ? R(x, 2 * p + 1) : R(x, 2 * p + 2)) + x[p];
    return d;//计算当前节点的左右子节点的值，找出较大值，然后将这个较大值与当前节点的值相加
}
int main(void) 
{
    vector<int> x;
    int L = 0, T = 0, H = 0;//L 用于读取输入，T用于存储总节点数，H用于存储树的高度
    long e = 0;
    while(cin >> L) 
    x.push_back(L);
    if(x[0] == -1) 
    {
        cout << 0 << endl << 0 << endl << 0;
        return 0;
    }//特殊情况
    T = x.size();
    if(T) 
    {
        L = 1;
        while(L <= T) 
        {
            L = L * 2;
            H++;
        }//计算高度
    }
    bool left = false, right = false;
    for (int i = 0; i < T; ++i) {
        if(i * 2 + 1 < T && x[i * 2 + 1] != -1) 
        left = true;
        if(i * 2 + 2 < T && x[i * 2 + 2] != -1) 
        right = true;
        if(left || right) 
        {
            if(left && right && x[i] > x[i * 2 + 1] && x[i] > x[i * 2 + 2]) 
            e += x[i]; //如果当前节点既有左子节点又有右子节点，并且当前节点的值大于其左右子节点的值
            else if(left && x[i] > x[i * 2 + 1] && !right) 
            e += x[i];// 如果当前节点只有左子节点，并且当前节点的值大于其左子节点的值
            else if(right && x[i] > x[i * 2 + 2] && !left) 
            e += x[i]; //如果当前节点只有右子节点，并且当前节点的值大于其右子节点的值
        }
        left = false, right = false;
    }
    cout << H << endl;
    cout << R(x, 0) << endl;
    cout << e << endl;
    return 0;
}