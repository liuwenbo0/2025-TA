#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class BTree {
public:
    vector<int> vals;
    int h;
    long long sp_sum;

    BTree() : h(0), sp_sum(0) {}

    void read() {
        int val;
        while (cin >> val) {
            vals.push_back(val);
        }
    }

    void run() {
        if (vals.empty() || vals[0] == -1) {
            cout << 0 << endl << 0 << endl << 0;
            return;
        }

        get_h();
        get_sp();
        cout << h << endl;
        cout << get_max(0) << endl;
        cout << sp_sum << endl;
    }

private:
    int get_max(size_t p) {
        if (p >= vals.size() || vals[p] == -1) return 0;
        return max(get_max(2 * p + 1), get_max(2 * p + 2)) + vals[p];
    }

    void get_h() {
        size_t level = 1;
        while (level <= vals.size()) {
            level *= 2;
            h++;
        }
    }

    void get_sp() {
        for (size_t p = 0; p < vals.size(); ++p) {
            if (non_leaf(p) && is_sp(p)) {
                sp_sum += vals[p];
            }
        }
    }

    bool non_leaf(size_t p) {
        return (2 * p + 1 < vals.size() && vals[2 * p + 1] != -1) ||
               (2 * p + 2 < vals.size() && vals[2 * p + 2] != -1);
    }

    bool is_sp(size_t p) {
        bool left = 2 * p + 1 < vals.size() && vals[2 * p + 1] != -1;
        bool right = 2 * p + 2 < vals.size() && vals[2 * p + 2] != -1;

        if (left && right) {
            return vals[p] > vals[2 * p + 1] && vals[p] > vals[2 * p + 2];
        } else if (left) {
            return vals[p] > vals[2 * p + 1];
        } else if (right) {
            return vals[p] > vals[2 * p + 2];
        }
        return false;
    }
};

int main()
{
    BTree t;
    t.read();
    t.run();
    return 0;
}