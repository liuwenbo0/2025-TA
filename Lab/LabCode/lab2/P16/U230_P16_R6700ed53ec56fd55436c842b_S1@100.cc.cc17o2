#include "Solution.h"
int Solution::find_maximum_crossing_subarray(vector<int> &A, int low, int mid, int high) {
    // 请在这里完成你的代码
    int left_sum=INT_MIN;
    int sum=0;
    for(int i=mid;i>=low;i--){
      sum+=A[i];
      if(sum>left_sum){
        left_sum=sum;
      }
    }
    int right_sum=INT_MIN;
    sum=0;
    for(int j=mid+1;j<=high;j++){
      sum+=A[j];
      if(sum>right_sum){
        right_sum=sum;
      }
    }
    return left_sum+right_sum;
}
int Solution::find_maximum_subarray(vector<int> &A, int low, int high) {
    // 请在这里完成你的代码
    if(low==high){
      return A[low];
    }
    int mid=(low+high)/2;
    int left_max=find_maximum_subarray(A,low,mid);//左半递归
    int right_max=find_maximum_subarray(A,mid+1,high);//右半递归
    int cross_max=find_maximum_crossing_subarray(A,low,mid,high);//一个元素时回溯，找横跨最大
    return max(left_max,max(right_max,cross_max));
  }