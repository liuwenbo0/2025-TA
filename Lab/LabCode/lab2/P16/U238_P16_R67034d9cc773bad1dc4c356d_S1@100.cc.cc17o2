#include "Solution.h"
int Solution::find_maximum_crossing_subarray(vector<int> &A, int low, int mid, int high) {
    // 请在这里完成你的代码
    // 找到左半部分包含中点的最大子数组和  
    int sum = 0;  
    int left_sum = -10000;  
    for (int i = mid; i >= low; --i) {  
        sum += A[i];  
        if (sum > left_sum) {  
            left_sum = sum;  
        }  
    }  
  
    // 找到右半部分包含中点的最大子数组和  
    sum = 0;  
    int right_sum = -10000;  
    for (int j = mid + 1; j <= high; ++j) {  
        sum += A[j];  
        if (sum > right_sum) {  
            right_sum = sum;  
        }  
    }  
  
    // 返回跨越中点的最大子数组和  
    return left_sum + right_sum;  
}  

int Solution::find_maximum_subarray(vector<int> &A, int low, int high) {
    // 请在这里完成你的代码
    if (low == high) {  
        // 如果只有一个元素，那么直接返回该元素  
        return A[low];  
    } 
    else {  
        int mid = low + (high - low) / 2;  
  
        // 递归求解左半部分的最大子数组和  
        int left_max = find_maximum_subarray(A, low, mid);  
  
        // 递归求解右半部分的最大子数组和  
        int right_max = find_maximum_subarray(A, mid + 1, high);  
  
        // 求解跨越中点的最大子数组和  
        int cross_max = find_maximum_crossing_subarray(A, low, mid, high);  
  
        // 返回三者中的最大值  
        return max(max(left_max, right_max), cross_max);  
    }
}