#include "Solution.h"
vector<vector<int>> Solution::round_robin_schedule(int n) 
{
    // 如此构造一个二维数组（ nxn 矩阵）
    vector<vector<int> > ans;
    for(int i=0; i<n; i++) 
    {
      ans.push_back(vector<int>(n, 0));

    }
    // 
    int k;
    int m;
    for(m=n,k=0;m>2;m=m/2)
    {
        k++;
    } 
    int sd[2][2];
    sd[0][0]=1;
    sd[0][1]=2;
    sd[1][0]=2;
    sd[1][1]=1;

    for(;k>0;k--)
    {
        spread sd[][];
    }

    for(int i=0;i<2l-1;i++)
    {
        for(int j=0;i<2l-1;j++)
        {
            printf sd[i][j];
        }
    }        
    return ans;
}

void spread(int a[n][n])
{
    int l;
    l=n;
    int b[l][l];
    int c[l][l];
    int d[l][l];
    for(int i=0;i<l-1;i++)
    {
        for(int j=0;i<l-1;j++)
        {
            b[i][j]=a[i][j]+l;
            c[i][j]=b[j][i];
            d[i][j]=a[i][j];
        }
    }

    int F[2l][2l];
    for(int i=0;i<l-1;i++)
    {
        for(int j=0;i<l-1;j++)
        {
            F[i][j]=a[i][j];
        }
    }

    for(int i=l;i<2l-1;i++)
    {
        for(int j=0;i<l-1;j++)
        {
            F[i][j]=c[i][j];
        }
    }
    
    for(int i=0;i<l-1;i++)
    {
        for(int j=l;i<2l-1;j++)
        {
            F[i][j]=b[i][j];
        }
    }

    for(int i=l;i<2l-1;i++)
    {
        for(int j=l;i<2l-1;j++)
        {
            F[i][j]=a[i][j];
        }
    }

    return F;
}