#include <iostream>
using namespace std;

// Function to determine the depth of the tree
int computeDepth(int treeData[], int node, int size) {
    int leftDepth, rightDepth;
    if (treeData[node] == -1 || node >= size) return 0;
    else {
        leftDepth = computeDepth(treeData, 2 * node + 1, size);
        rightDepth = computeDepth(treeData, 2 * node + 2, size);
        return (leftDepth >= rightDepth) ? leftDepth + 1 : rightDepth + 1;
    }
}

// Function to compute the maximal path sum in the tree
int greatestPathSum(int treeData[], int node, int size) {
    int leftSum = 0, rightSum = 0;
    if (treeData[node] == -1 || node >= size) return 0;
    else {
        leftSum = greatestPathSum(treeData, 2 * node + 1, size);
        rightSum = greatestPathSum(treeData, 2 * node + 2, size);
        return (rightSum >= leftSum) ? rightSum + treeData[node] : leftSum + treeData[node];
    }
}

// Function to compute the ideal value based on specific conditions
int idealValue(int treeData[], int node, int size) {
    if (treeData[node] == -1 || node >= size) return 0;
    else if (treeData[2 * node + 1] == -1 && treeData[2 * node + 2] == -1) return 0;
    else if ((2 * node + 1) >= size && (2 * node + 2) >= size) return 0;
    else if (treeData[node] > treeData[2 * node + 1] && treeData[node] > treeData[2 * node + 2])
        return treeData[node] + idealValue(treeData, 2 * node + 1, size) + idealValue(treeData, 2 * node + 2, size);
    else 
        return idealValue(treeData, 2 * node + 1, size) + idealValue(treeData, 2 * node + 2, size);
}

int main() {
    int element;
    int treeElements[10000000];
    int index = 0;
    for(index = 0; cin >> element; index++) {
        treeElements[index] = element;
    }
    cout << computeDepth(treeElements, 0, index) << endl;
    cout << greatestPathSum(treeElements, 0, index) << endl;
    cout << idealValue(treeElements, 0, index);
    return 0;
}