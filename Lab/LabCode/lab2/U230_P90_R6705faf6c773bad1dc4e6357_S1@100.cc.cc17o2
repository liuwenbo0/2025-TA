#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

struct TreeNode {
    int value;
    vector<TreeNode*> children;

    TreeNode(int val) : value(val) {}
};

// 构建树
TreeNode* buildTree(const vector<int>& Order) {
    if (Order.empty()) return NULL;

    TreeNode* root = new TreeNode(Order[0]);
    queue<TreeNode*> q;
    q.push(root);  // 根节点入队
    
    int n = Order.size();
    int index = 1;

    while (!q.empty() && index < n) {
        TreeNode* current = q.front();
        q.pop();

        // 为当前节点添加左孩子
        if (index < n) {
            TreeNode* leftChild = new TreeNode(Order[index]);
            current->children.push_back(leftChild);
            q.push(leftChild);
        }
        index++; // 左孩子索引向后移动

        // 为当前节点添加右孩子
        if (index < n) {
            TreeNode* rightChild = new TreeNode(Order[index]);
            current->children.push_back(rightChild);
            q.push(rightChild);
        }
        index++; // 右孩子索引向后移动
    }
    return root;
}

// 计算树的高度
int treeHeight(TreeNode* node) {
    if (!node) return 0;
    int maxHeight = 0;

    for (TreeNode* child : node->children) {
        if (child->value != -1)
            maxHeight = max(maxHeight, treeHeight(child));
    }
    return maxHeight + 1;
}

// 计算资源最丰富路径和
int maxResourcePath(TreeNode* node) {
    if (!node) return 0;
    if (node->children.empty() && node->value != -1){
        return node->value; // 是叶节点
    }
    int maxChildSum = 0;
    
    for (TreeNode* child : node->children) { // 遍历叶节点
        if (child->value != -1)
            maxChildSum = max(maxChildSum, maxResourcePath(child)); //递归，更新最大值
    }
    return node->value + maxChildSum;
}

// 计算特殊区域的节点值和
int specialRegionSum(TreeNode* node) {
    if (!node || node->value == -1) return 0; // 检查非叶子节点

    int sumSpecialNodes = 0;
    bool isSpecial = false;

    for (TreeNode* child : node->children) {
        if (child->value != -1) { // 检查有无子节点
            isSpecial = true;
            break;
        }
    }

    for (TreeNode* child : node->children) {
        if (node->value <= child->value) { // 检查特殊条件
            isSpecial = false;
        }
    }
    
    if (isSpecial) {
        sumSpecialNodes += node->value;
    }

    for (TreeNode* child : node->children) {  // 对子节点递归调用
        sumSpecialNodes += specialRegionSum(child);
    }
    
    return sumSpecialNodes;
}

// 处理
void processTree(vector<int>& levelOrder) {
    TreeNode* root = buildTree(levelOrder);
    
    int height = treeHeight(root);
    int maxPathSum = maxResourcePath(root);
    int specialAreaValueSum = specialRegionSum(root);

    // 输出
    cout << height << endl;
    cout << maxPathSum << endl;
    cout << specialAreaValueSum << endl;

}

int main() {
    vector<int> Order;
    int value;

    // 输入数据
    while (cin >> value) {
        Order.push_back(value);
        if (cin.peek() == '\n') break; // 读完一行的数据
    }

    processTree(Order);

    return 0;
}