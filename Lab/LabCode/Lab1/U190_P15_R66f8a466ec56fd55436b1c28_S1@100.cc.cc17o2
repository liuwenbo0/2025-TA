#include<iostream>
#include<vector>
using namespace std;
static int all_counting = 0;
static int counting = 0;
void mysort(std::vector<int>& nums) {
	
	for (int i = 1; i<int(nums.size()); i++)
	{

		int key = nums[i];
		int j = i - 1;
		if (nums[j] <= key)
		{
			counting++;
		}
		while (j >= 0 && nums[j] > key)
		{
			nums[j + 1] = nums[j];
			j--;
			counting++;
			if (j >= 0 && nums[j] <= key)
			{
				counting++;
			}
		}
		nums[j + 1] = key;
	}
}
// 通过归并排序对int队列nums中的[left, right]区间进行升序排序
// @param
// nums: 完整的待排序队列，最终排序的结果应存放在nums中
// left: 当前排序区间的左端点
// right: 当前排序区间的右端点
void merge(std::vector<int>& nums, int left, int mid, int right)
{
	int* nums_k = new int[right - left + 1];
	int i = left, j = mid + 1, k = 0;
	while (i <= mid && j <= right)
	{
		if (nums[i] <= nums[j])
		{
			nums_k[k++] = nums[i++];
			all_counting++;
		}
		else
		{
			nums_k[k++] = nums[j++];
			all_counting++;
		}
	}
	while (i <= mid)
	{
		nums_k[k++] = nums[i++];
	}
	while (j <= right)
	{
		nums_k[k++] = nums[j++];
	}
	k = 0;
	for (int i = left; i <= right; i++)
	{
		nums[i] = nums_k[k++];
	}
	delete[]nums_k;

}
void merge_sort_aux(std::vector<int>& nums, int left, int right)
{
	if (left < right)
	{
		int mid = (left + right) / 2;
		merge_sort_aux(nums, left, mid);
		merge_sort_aux(nums, mid + 1, right);
		merge(nums, left, mid, right);
	}

}
int main()
{
	int n;
	cin >> n;
	vector<int>A;
	vector<int>B;
	for (int i = 0; i < n; i++)
	{
		int p = 0;
		cin >> p;
		A.push_back(p);
		B.push_back(p);
	}
	merge_sort_aux(A,0,int(A.size()-1));
	mysort(B);

	cout <<all_counting<<" "<<counting << endl;
}