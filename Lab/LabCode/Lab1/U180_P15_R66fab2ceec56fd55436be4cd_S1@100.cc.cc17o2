#include<iostream>
#include<vector>
using namespace std;
void mysort(vector<int>& nums,int& count) {
 int n = nums.size();
 for (int i = 1; i < n; i++) {
 int key = nums[i];
 int j = i - 1;
 // 将nums[i]插入到已排序的序列中
 while (j >= 0 &&++count&& nums[j] > key) {
 nums[j + 1] = nums[j];
 j = j - 1;
 }
 nums[j + 1] = key;
 }
 //cnt = 0; // 如果需要统计比较次数，可以在每次比较时增加cnt
}
void merge_sort_aux(std::vector<int> &nums, int left, int right ,int&count1) {
 if (left >= right) return; // 如果区间只有一个元素或没有元素，则不需要排序

 int mid = left + (right - left) / 2; // 计算中间点，避免溢出
 merge_sort_aux(nums, left, mid,count1); // 递归排序左半部分
 merge_sort_aux(nums, mid + 1, right,count1); // 递归排序右半部分

 // 合并两个已排序的区间
 std::vector<int> temp(right - left + 1); // 创建临时数组用于存放合并后的数组
 int i = left, j = mid + 1, k = 0; // 初始化三个指针

 while (i <= mid && j <= right) {
 count1++;
 if (nums[i] <= nums[j]) {
 temp[k++] = nums[i++];
 } else {
 temp[k++] = nums[j++];
 }
 }

 // 复制剩余的元素
 while (i <= mid) {
 temp[k++] = nums[i++];
 }
 while (j <= right) {
 temp[k++] = nums[j++];
 }

 // 将合并后的数组复制回原数组
 for (i = left, k = 0; i <= right; ++i, ++k) {
 nums[i] = temp[k];
 }
}

int main(){
 int N;
 cin>>N;
 vector<int> arr1(N),arr2(N);
 int i;
 for(i=0;i<N;i++){
 cin>>arr1[i];
 arr2[i]=arr1[i];
 }
int Merge=0,insort=0;
 mysort(arr2,insort);
 merge_sort_aux(arr1,0,N-1,Merge);
 
 cout<<Merge<<" "<<insort<<endl;
}